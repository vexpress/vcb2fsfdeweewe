{"ast":null,"code":"import { load } from '@porsche-design-system/components-js';\nexport { componentsReady } from '@porsche-design-system/components-js';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, NgModule, Optional, Injectable } from '@angular/core';\nconst _c0 = [\"*\"];\nconst proxyInputs = (component, inputs) => {\n  const callback = item => {\n    Object.defineProperty(component.prototype, item, {\n      get() {\n        return this.el[item];\n      },\n      set(val) {\n        this.z.runOutsideAngular(() => this.el[item] = val);\n      }\n    });\n  };\n  inputs.forEach(callback);\n};\n// NOTE: only relevant if components use the @Method() decorator\n// currently our AngularWrapperGenerator doesn't support this\n// const proxyMethods = (Cmp: any, methods: string[]) => {\n//   const Prototype = Cmp.prototype;\n//   methods.forEach((methodName) => {\n//     Prototype[methodName] = function () {\n//       const args = arguments;\n//       return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));\n//     };\n//   });\n// };\nconst proxyOutputs = (instance, events) => {\n  events.forEach(event => instance[event] = new EventEmitter());\n};\n// tslint:disable-next-line: only-arrow-functions\nfunction ProxyCmp({\n  inputs /*, methods*/\n}) {\n  return function (component) {\n    if (inputs) {\n      proxyInputs(component, inputs);\n    }\n    // if (methods) {\n    //   proxyMethods(component, methods);\n    // }\n    return component;\n  };\n}\nvar __decorate$P = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$K = ['compact', 'heading', 'open', 'size', 'tag', 'theme'];\nconst outputs$c = ['accordionChange'];\nlet PAccordion = /*#__PURE__*/(() => {\n  let PAccordion = class PAccordion {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$c);\n    }\n  };\n  PAccordion.ɵfac = function PAccordion_Factory(t) {\n    return new (t || PAccordion)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PAccordion.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PAccordion,\n    selectors: [[\"p-accordion\"], [\"\", \"p-accordion\", \"\"]],\n    inputs: {\n      compact: \"compact\",\n      heading: \"heading\",\n      open: \"open\",\n      size: \"size\",\n      tag: \"tag\",\n      theme: \"theme\"\n    },\n    outputs: {\n      accordionChange: \"accordionChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PAccordion_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PAccordion;\n})();\nPAccordion = __decorate$P([ProxyCmp({\n  inputs: inputs$K\n})], PAccordion);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$O = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$J = ['persistent', 'state', 'theme', 'width'];\nconst outputs$b = ['dismiss'];\nlet PBanner = /*#__PURE__*/(() => {\n  let PBanner = class PBanner {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$b);\n    }\n  };\n  PBanner.ɵfac = function PBanner_Factory(t) {\n    return new (t || PBanner)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PBanner.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PBanner,\n    selectors: [[\"p-banner\"], [\"\", \"p-banner\", \"\"]],\n    inputs: {\n      persistent: \"persistent\",\n      state: \"state\",\n      theme: \"theme\",\n      width: \"width\"\n    },\n    outputs: {\n      dismiss: \"dismiss\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PBanner_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PBanner;\n})();\nPBanner = __decorate$O([ProxyCmp({\n  inputs: inputs$J\n})], PBanner);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$N = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$I = ['aria', 'disabled', 'hideLabel', 'icon', 'iconSource', 'loading', 'tabbable', 'theme', 'type', 'variant'];\nlet PButton = /*#__PURE__*/(() => {\n  let PButton = class PButton {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PButton.ɵfac = function PButton_Factory(t) {\n    return new (t || PButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PButton,\n    selectors: [[\"p-button\"], [\"\", \"p-button\", \"\"]],\n    inputs: {\n      aria: \"aria\",\n      disabled: \"disabled\",\n      hideLabel: \"hideLabel\",\n      icon: \"icon\",\n      iconSource: \"iconSource\",\n      loading: \"loading\",\n      tabbable: \"tabbable\",\n      theme: \"theme\",\n      type: \"type\",\n      variant: \"variant\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PButton_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PButton;\n})();\nPButton = __decorate$N([ProxyCmp({\n  inputs: inputs$I\n})], PButton);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$M = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$H = ['direction'];\nlet PButtonGroup = /*#__PURE__*/(() => {\n  let PButtonGroup = class PButtonGroup {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PButtonGroup.ɵfac = function PButtonGroup_Factory(t) {\n    return new (t || PButtonGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PButtonGroup.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PButtonGroup,\n    selectors: [[\"p-button-group\"], [\"\", \"p-button-group\", \"\"]],\n    inputs: {\n      direction: \"direction\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PButtonGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PButtonGroup;\n})();\nPButtonGroup = __decorate$M([ProxyCmp({\n  inputs: inputs$H\n})], PButtonGroup);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$L = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$G = ['active', 'alignLabel', 'aria', 'disabled', 'hideLabel', 'icon', 'iconSource', 'loading', 'size', 'stretch', 'tabbable', 'theme', 'type', 'weight'];\nlet PButtonPure = /*#__PURE__*/(() => {\n  let PButtonPure = class PButtonPure {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PButtonPure.ɵfac = function PButtonPure_Factory(t) {\n    return new (t || PButtonPure)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PButtonPure.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PButtonPure,\n    selectors: [[\"p-button-pure\"], [\"\", \"p-button-pure\", \"\"]],\n    inputs: {\n      active: \"active\",\n      alignLabel: \"alignLabel\",\n      aria: \"aria\",\n      disabled: \"disabled\",\n      hideLabel: \"hideLabel\",\n      icon: \"icon\",\n      iconSource: \"iconSource\",\n      loading: \"loading\",\n      size: \"size\",\n      stretch: \"stretch\",\n      tabbable: \"tabbable\",\n      theme: \"theme\",\n      type: \"type\",\n      weight: \"weight\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PButtonPure_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PButtonPure;\n})();\nPButtonPure = __decorate$L([ProxyCmp({\n  inputs: inputs$G\n})], PButtonPure);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$K = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$F = ['description', 'disablePagination', 'heading', 'intl', 'rewind', 'slidesPerPage', 'theme', 'wrapContent'];\nconst outputs$a = ['carouselChange'];\nlet PCarousel = /*#__PURE__*/(() => {\n  let PCarousel = class PCarousel {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$a);\n    }\n  };\n  PCarousel.ɵfac = function PCarousel_Factory(t) {\n    return new (t || PCarousel)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PCarousel.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PCarousel,\n    selectors: [[\"p-carousel\"], [\"\", \"p-carousel\", \"\"]],\n    inputs: {\n      description: \"description\",\n      disablePagination: \"disablePagination\",\n      heading: \"heading\",\n      intl: \"intl\",\n      rewind: \"rewind\",\n      slidesPerPage: \"slidesPerPage\",\n      theme: \"theme\",\n      wrapContent: \"wrapContent\"\n    },\n    outputs: {\n      carouselChange: \"carouselChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PCarousel_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PCarousel;\n})();\nPCarousel = __decorate$K([ProxyCmp({\n  inputs: inputs$F\n})], PCarousel);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$J = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$E = ['hideLabel', 'label', 'message', 'state'];\nlet PCheckboxWrapper = /*#__PURE__*/(() => {\n  let PCheckboxWrapper = class PCheckboxWrapper {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PCheckboxWrapper.ɵfac = function PCheckboxWrapper_Factory(t) {\n    return new (t || PCheckboxWrapper)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PCheckboxWrapper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PCheckboxWrapper,\n    selectors: [[\"p-checkbox-wrapper\"], [\"\", \"p-checkbox-wrapper\", \"\"]],\n    inputs: {\n      hideLabel: \"hideLabel\",\n      label: \"label\",\n      message: \"message\",\n      state: \"state\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PCheckboxWrapper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PCheckboxWrapper;\n})();\nPCheckboxWrapper = __decorate$J([ProxyCmp({\n  inputs: inputs$E\n})], PCheckboxWrapper);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$I = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$D = ['backgroundColor', 'theme', 'width'];\nlet PContentWrapper = /*#__PURE__*/(() => {\n  let PContentWrapper = class PContentWrapper {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PContentWrapper.ɵfac = function PContentWrapper_Factory(t) {\n    return new (t || PContentWrapper)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PContentWrapper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PContentWrapper,\n    selectors: [[\"p-content-wrapper\"], [\"\", \"p-content-wrapper\", \"\"]],\n    inputs: {\n      backgroundColor: \"backgroundColor\",\n      theme: \"theme\",\n      width: \"width\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PContentWrapper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PContentWrapper;\n})();\nPContentWrapper = __decorate$I([ProxyCmp({\n  inputs: inputs$D\n})], PContentWrapper);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$H = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$C = ['color', 'orientation', 'theme'];\nlet PDivider = /*#__PURE__*/(() => {\n  let PDivider = class PDivider {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PDivider.ɵfac = function PDivider_Factory(t) {\n    return new (t || PDivider)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PDivider.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PDivider,\n    selectors: [[\"p-divider\"], [\"\", \"p-divider\", \"\"]],\n    inputs: {\n      color: \"color\",\n      orientation: \"orientation\",\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PDivider_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PDivider;\n})();\nPDivider = __decorate$H([ProxyCmp({\n  inputs: inputs$C\n})], PDivider);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$G = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$B = ['label', 'labelSize', 'message', 'required', 'state'];\nlet PFieldsetWrapper = /*#__PURE__*/(() => {\n  let PFieldsetWrapper = class PFieldsetWrapper {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PFieldsetWrapper.ɵfac = function PFieldsetWrapper_Factory(t) {\n    return new (t || PFieldsetWrapper)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PFieldsetWrapper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PFieldsetWrapper,\n    selectors: [[\"p-fieldset-wrapper\"], [\"\", \"p-fieldset-wrapper\", \"\"]],\n    inputs: {\n      label: \"label\",\n      labelSize: \"labelSize\",\n      message: \"message\",\n      required: \"required\",\n      state: \"state\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PFieldsetWrapper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PFieldsetWrapper;\n})();\nPFieldsetWrapper = __decorate$G([ProxyCmp({\n  inputs: inputs$B\n})], PFieldsetWrapper);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$F = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$A = ['alignContent', 'alignItems', 'direction', 'inline', 'justifyContent', 'wrap'];\nlet PFlex = /*#__PURE__*/(() => {\n  let PFlex = class PFlex {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PFlex.ɵfac = function PFlex_Factory(t) {\n    return new (t || PFlex)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PFlex.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PFlex,\n    selectors: [[\"p-flex\"], [\"\", \"p-flex\", \"\"]],\n    inputs: {\n      alignContent: \"alignContent\",\n      alignItems: \"alignItems\",\n      direction: \"direction\",\n      inline: \"inline\",\n      justifyContent: \"justifyContent\",\n      wrap: \"wrap\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PFlex_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PFlex;\n})();\nPFlex = __decorate$F([ProxyCmp({\n  inputs: inputs$A\n})], PFlex);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$E = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$z = ['alignSelf', 'flex', 'grow', 'offset', 'shrink', 'width'];\nlet PFlexItem = /*#__PURE__*/(() => {\n  let PFlexItem = class PFlexItem {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PFlexItem.ɵfac = function PFlexItem_Factory(t) {\n    return new (t || PFlexItem)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PFlexItem.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PFlexItem,\n    selectors: [[\"p-flex-item\"], [\"\", \"p-flex-item\", \"\"]],\n    inputs: {\n      alignSelf: \"alignSelf\",\n      flex: \"flex\",\n      grow: \"grow\",\n      offset: \"offset\",\n      shrink: \"shrink\",\n      width: \"width\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PFlexItem_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PFlexItem;\n})();\nPFlexItem = __decorate$E([ProxyCmp({\n  inputs: inputs$z\n})], PFlexItem);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$D = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$y = ['direction', 'gutter', 'wrap'];\nlet PGrid = /*#__PURE__*/(() => {\n  let PGrid = class PGrid {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PGrid.ɵfac = function PGrid_Factory(t) {\n    return new (t || PGrid)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PGrid.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PGrid,\n    selectors: [[\"p-grid\"], [\"\", \"p-grid\", \"\"]],\n    inputs: {\n      direction: \"direction\",\n      gutter: \"gutter\",\n      wrap: \"wrap\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PGrid_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PGrid;\n})();\nPGrid = __decorate$D([ProxyCmp({\n  inputs: inputs$y\n})], PGrid);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$C = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$x = ['offset', 'size'];\nlet PGridItem = /*#__PURE__*/(() => {\n  let PGridItem = class PGridItem {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PGridItem.ɵfac = function PGridItem_Factory(t) {\n    return new (t || PGridItem)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PGridItem.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PGridItem,\n    selectors: [[\"p-grid-item\"], [\"\", \"p-grid-item\", \"\"]],\n    inputs: {\n      offset: \"offset\",\n      size: \"size\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PGridItem_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PGridItem;\n})();\nPGridItem = __decorate$C([ProxyCmp({\n  inputs: inputs$x\n})], PGridItem);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$B = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$w = ['align', 'color', 'ellipsis', 'tag', 'theme', 'variant'];\nlet PHeadline = /*#__PURE__*/(() => {\n  let PHeadline = class PHeadline {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PHeadline.ɵfac = function PHeadline_Factory(t) {\n    return new (t || PHeadline)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PHeadline.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PHeadline,\n    selectors: [[\"p-headline\"], [\"\", \"p-headline\", \"\"]],\n    inputs: {\n      align: \"align\",\n      color: \"color\",\n      ellipsis: \"ellipsis\",\n      tag: \"tag\",\n      theme: \"theme\",\n      variant: \"variant\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PHeadline_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PHeadline;\n})();\nPHeadline = __decorate$B([ProxyCmp({\n  inputs: inputs$w\n})], PHeadline);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$A = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$v = ['aria', 'color', 'lazy', 'name', 'size', 'source', 'theme'];\nlet PIcon = /*#__PURE__*/(() => {\n  let PIcon = class PIcon {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PIcon.ɵfac = function PIcon_Factory(t) {\n    return new (t || PIcon)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PIcon.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PIcon,\n    selectors: [[\"p-icon\"], [\"\", \"p-icon\", \"\"]],\n    inputs: {\n      aria: \"aria\",\n      color: \"color\",\n      lazy: \"lazy\",\n      name: \"name\",\n      size: \"size\",\n      source: \"source\",\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PIcon_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PIcon;\n})();\nPIcon = __decorate$A([ProxyCmp({\n  inputs: inputs$v\n})], PIcon);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$z = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$u = ['actionIcon', 'actionLabel', 'actionLoading', 'description', 'heading', 'persistent', 'state', 'theme'];\nconst outputs$9 = ['action', 'dismiss'];\nlet PInlineNotification = /*#__PURE__*/(() => {\n  let PInlineNotification = class PInlineNotification {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$9);\n    }\n  };\n  PInlineNotification.ɵfac = function PInlineNotification_Factory(t) {\n    return new (t || PInlineNotification)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PInlineNotification.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PInlineNotification,\n    selectors: [[\"p-inline-notification\"], [\"\", \"p-inline-notification\", \"\"]],\n    inputs: {\n      actionIcon: \"actionIcon\",\n      actionLabel: \"actionLabel\",\n      actionLoading: \"actionLoading\",\n      description: \"description\",\n      heading: \"heading\",\n      persistent: \"persistent\",\n      state: \"state\",\n      theme: \"theme\"\n    },\n    outputs: {\n      action: \"action\",\n      dismiss: \"dismiss\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PInlineNotification_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PInlineNotification;\n})();\nPInlineNotification = __decorate$z([ProxyCmp({\n  inputs: inputs$u\n})], PInlineNotification);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$y = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$t = ['aria', 'download', 'hideLabel', 'href', 'icon', 'iconSource', 'rel', 'target', 'theme', 'variant'];\nlet PLink = /*#__PURE__*/(() => {\n  let PLink = class PLink {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PLink.ɵfac = function PLink_Factory(t) {\n    return new (t || PLink)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PLink.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PLink,\n    selectors: [[\"p-link\"], [\"\", \"p-link\", \"\"]],\n    inputs: {\n      aria: \"aria\",\n      download: \"download\",\n      hideLabel: \"hideLabel\",\n      href: \"href\",\n      icon: \"icon\",\n      iconSource: \"iconSource\",\n      rel: \"rel\",\n      target: \"target\",\n      theme: \"theme\",\n      variant: \"variant\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PLink_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PLink;\n})();\nPLink = __decorate$y([ProxyCmp({\n  inputs: inputs$t\n})], PLink);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$x = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$s = ['active', 'alignLabel', 'aria', 'download', 'hideLabel', 'href', 'icon', 'iconSource', 'rel', 'size', 'stretch', 'target', 'theme', 'weight'];\nlet PLinkPure = /*#__PURE__*/(() => {\n  let PLinkPure = class PLinkPure {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PLinkPure.ɵfac = function PLinkPure_Factory(t) {\n    return new (t || PLinkPure)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PLinkPure.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PLinkPure,\n    selectors: [[\"p-link-pure\"], [\"\", \"p-link-pure\", \"\"]],\n    inputs: {\n      active: \"active\",\n      alignLabel: \"alignLabel\",\n      aria: \"aria\",\n      download: \"download\",\n      hideLabel: \"hideLabel\",\n      href: \"href\",\n      icon: \"icon\",\n      iconSource: \"iconSource\",\n      rel: \"rel\",\n      size: \"size\",\n      stretch: \"stretch\",\n      target: \"target\",\n      theme: \"theme\",\n      weight: \"weight\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PLinkPure_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PLinkPure;\n})();\nPLinkPure = __decorate$x([ProxyCmp({\n  inputs: inputs$s\n})], PLinkPure);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$w = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$r = ['hideLabel', 'href', 'icon', 'iconSource', 'rel', 'target', 'theme'];\nlet PLinkSocial = /*#__PURE__*/(() => {\n  let PLinkSocial = class PLinkSocial {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PLinkSocial.ɵfac = function PLinkSocial_Factory(t) {\n    return new (t || PLinkSocial)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PLinkSocial.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PLinkSocial,\n    selectors: [[\"p-link-social\"], [\"\", \"p-link-social\", \"\"]],\n    inputs: {\n      hideLabel: \"hideLabel\",\n      href: \"href\",\n      icon: \"icon\",\n      iconSource: \"iconSource\",\n      rel: \"rel\",\n      target: \"target\",\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PLinkSocial_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PLinkSocial;\n})();\nPLinkSocial = __decorate$w([ProxyCmp({\n  inputs: inputs$r\n})], PLinkSocial);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$v = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$q = ['align', 'aria', 'aspectRatio', 'compact', 'description', 'download', 'gradient', 'href', 'label', 'rel', 'size', 'target', 'weight'];\nlet PLinkTile = /*#__PURE__*/(() => {\n  let PLinkTile = class PLinkTile {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PLinkTile.ɵfac = function PLinkTile_Factory(t) {\n    return new (t || PLinkTile)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PLinkTile.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PLinkTile,\n    selectors: [[\"p-link-tile\"], [\"\", \"p-link-tile\", \"\"]],\n    inputs: {\n      align: \"align\",\n      aria: \"aria\",\n      aspectRatio: \"aspectRatio\",\n      compact: \"compact\",\n      description: \"description\",\n      download: \"download\",\n      gradient: \"gradient\",\n      href: \"href\",\n      label: \"label\",\n      rel: \"rel\",\n      size: \"size\",\n      target: \"target\",\n      weight: \"weight\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PLinkTile_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PLinkTile;\n})();\nPLinkTile = __decorate$v([ProxyCmp({\n  inputs: inputs$q\n})], PLinkTile);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$u = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$p = ['aria', 'href', 'size', 'target', 'trademark', 'variant'];\nlet PMarque = /*#__PURE__*/(() => {\n  let PMarque = class PMarque {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PMarque.ɵfac = function PMarque_Factory(t) {\n    return new (t || PMarque)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PMarque.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PMarque,\n    selectors: [[\"p-marque\"], [\"\", \"p-marque\", \"\"]],\n    inputs: {\n      aria: \"aria\",\n      href: \"href\",\n      size: \"size\",\n      target: \"target\",\n      trademark: \"trademark\",\n      variant: \"variant\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PMarque_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PMarque;\n})();\nPMarque = __decorate$u([ProxyCmp({\n  inputs: inputs$p\n})], PMarque);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$t = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$o = ['aria', 'disableBackdropClick', 'disableCloseButton', 'fullscreen', 'heading', 'open'];\nconst outputs$8 = ['close'];\nlet PModal = /*#__PURE__*/(() => {\n  let PModal = class PModal {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$8);\n    }\n  };\n  PModal.ɵfac = function PModal_Factory(t) {\n    return new (t || PModal)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PModal.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PModal,\n    selectors: [[\"p-modal\"], [\"\", \"p-modal\", \"\"]],\n    inputs: {\n      aria: \"aria\",\n      disableBackdropClick: \"disableBackdropClick\",\n      disableCloseButton: \"disableCloseButton\",\n      fullscreen: \"fullscreen\",\n      heading: \"heading\",\n      open: \"open\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PModal_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PModal;\n})();\nPModal = __decorate$t([ProxyCmp({\n  inputs: inputs$o\n})], PModal);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$s = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$n = ['activePage', 'allyLabel', 'allyLabelNext', 'allyLabelPage', 'allyLabelPrev', 'itemsPerPage', 'maxNumberOfPageLinks', 'theme', 'totalItemsCount'];\nconst outputs$7 = ['pageChange'];\nlet PPagination = /*#__PURE__*/(() => {\n  let PPagination = class PPagination {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$7);\n    }\n  };\n  PPagination.ɵfac = function PPagination_Factory(t) {\n    return new (t || PPagination)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PPagination.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PPagination,\n    selectors: [[\"p-pagination\"], [\"\", \"p-pagination\", \"\"]],\n    inputs: {\n      activePage: \"activePage\",\n      allyLabel: \"allyLabel\",\n      allyLabelNext: \"allyLabelNext\",\n      allyLabelPage: \"allyLabelPage\",\n      allyLabelPrev: \"allyLabelPrev\",\n      itemsPerPage: \"itemsPerPage\",\n      maxNumberOfPageLinks: \"maxNumberOfPageLinks\",\n      theme: \"theme\",\n      totalItemsCount: \"totalItemsCount\"\n    },\n    outputs: {\n      pageChange: \"pageChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PPagination_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PPagination;\n})();\nPPagination = __decorate$s([ProxyCmp({\n  inputs: inputs$n\n})], PPagination);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$r = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$m = ['aria', 'description', 'direction'];\nlet PPopover = /*#__PURE__*/(() => {\n  let PPopover = class PPopover {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PPopover.ɵfac = function PPopover_Factory(t) {\n    return new (t || PPopover)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PPopover.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PPopover,\n    selectors: [[\"p-popover\"], [\"\", \"p-popover\", \"\"]],\n    inputs: {\n      aria: \"aria\",\n      description: \"description\",\n      direction: \"direction\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PPopover_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PPopover;\n})();\nPPopover = __decorate$r([ProxyCmp({\n  inputs: inputs$m\n})], PPopover);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$q = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$l = ['hideLabel', 'label', 'message', 'state'];\nlet PRadioButtonWrapper = /*#__PURE__*/(() => {\n  let PRadioButtonWrapper = class PRadioButtonWrapper {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PRadioButtonWrapper.ɵfac = function PRadioButtonWrapper_Factory(t) {\n    return new (t || PRadioButtonWrapper)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PRadioButtonWrapper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PRadioButtonWrapper,\n    selectors: [[\"p-radio-button-wrapper\"], [\"\", \"p-radio-button-wrapper\", \"\"]],\n    inputs: {\n      hideLabel: \"hideLabel\",\n      label: \"label\",\n      message: \"message\",\n      state: \"state\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PRadioButtonWrapper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PRadioButtonWrapper;\n})();\nPRadioButtonWrapper = __decorate$q([ProxyCmp({\n  inputs: inputs$l\n})], PRadioButtonWrapper);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$p = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$k = ['gradientColorScheme', 'scrollIndicatorPosition', 'scrollToPosition', 'theme'];\nlet PScroller = /*#__PURE__*/(() => {\n  let PScroller = class PScroller {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PScroller.ɵfac = function PScroller_Factory(t) {\n    return new (t || PScroller)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PScroller.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PScroller,\n    selectors: [[\"p-scroller\"], [\"\", \"p-scroller\", \"\"]],\n    inputs: {\n      gradientColorScheme: \"gradientColorScheme\",\n      scrollIndicatorPosition: \"scrollIndicatorPosition\",\n      scrollToPosition: \"scrollToPosition\",\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PScroller_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PScroller;\n})();\nPScroller = __decorate$p([ProxyCmp({\n  inputs: inputs$k\n})], PScroller);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$o = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$j = ['backgroundColor', 'theme', 'value'];\nconst outputs$6 = ['segmentedControlChange'];\nlet PSegmentedControl = /*#__PURE__*/(() => {\n  let PSegmentedControl = class PSegmentedControl {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$6);\n    }\n  };\n  PSegmentedControl.ɵfac = function PSegmentedControl_Factory(t) {\n    return new (t || PSegmentedControl)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PSegmentedControl.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PSegmentedControl,\n    selectors: [[\"p-segmented-control\"], [\"\", \"p-segmented-control\", \"\"]],\n    inputs: {\n      backgroundColor: \"backgroundColor\",\n      theme: \"theme\",\n      value: \"value\"\n    },\n    outputs: {\n      segmentedControlChange: \"segmentedControlChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PSegmentedControl_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PSegmentedControl;\n})();\nPSegmentedControl = __decorate$o([ProxyCmp({\n  inputs: inputs$j\n})], PSegmentedControl);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$n = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$i = ['disabled', 'icon', 'iconSource', 'label', 'value'];\nlet PSegmentedControlItem = /*#__PURE__*/(() => {\n  let PSegmentedControlItem = class PSegmentedControlItem {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PSegmentedControlItem.ɵfac = function PSegmentedControlItem_Factory(t) {\n    return new (t || PSegmentedControlItem)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PSegmentedControlItem.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PSegmentedControlItem,\n    selectors: [[\"p-segmented-control-item\"], [\"\", \"p-segmented-control-item\", \"\"]],\n    inputs: {\n      disabled: \"disabled\",\n      icon: \"icon\",\n      iconSource: \"iconSource\",\n      label: \"label\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PSegmentedControlItem_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PSegmentedControlItem;\n})();\nPSegmentedControlItem = __decorate$n([ProxyCmp({\n  inputs: inputs$i\n})], PSegmentedControlItem);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$m = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$h = ['description', 'dropdownDirection', 'filter', 'hideLabel', 'label', 'message', 'native', 'state', 'theme'];\nlet PSelectWrapper = /*#__PURE__*/(() => {\n  let PSelectWrapper = class PSelectWrapper {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PSelectWrapper.ɵfac = function PSelectWrapper_Factory(t) {\n    return new (t || PSelectWrapper)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PSelectWrapper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PSelectWrapper,\n    selectors: [[\"p-select-wrapper\"], [\"\", \"p-select-wrapper\", \"\"]],\n    inputs: {\n      description: \"description\",\n      dropdownDirection: \"dropdownDirection\",\n      filter: \"filter\",\n      hideLabel: \"hideLabel\",\n      label: \"label\",\n      message: \"message\",\n      native: \"native\",\n      state: \"state\",\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PSelectWrapper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PSelectWrapper;\n})();\nPSelectWrapper = __decorate$m([ProxyCmp({\n  inputs: inputs$h\n})], PSelectWrapper);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$l = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$g = ['aria', 'size', 'theme'];\nlet PSpinner = /*#__PURE__*/(() => {\n  let PSpinner = class PSpinner {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PSpinner.ɵfac = function PSpinner_Factory(t) {\n    return new (t || PSpinner)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PSpinner.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PSpinner,\n    selectors: [[\"p-spinner\"], [\"\", \"p-spinner\", \"\"]],\n    inputs: {\n      aria: \"aria\",\n      size: \"size\",\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PSpinner_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PSpinner;\n})();\nPSpinner = __decorate$l([ProxyCmp({\n  inputs: inputs$g\n})], PSpinner);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$k = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$f = ['size', 'theme'];\nconst outputs$5 = ['stepChange'];\nlet PStepperHorizontal = /*#__PURE__*/(() => {\n  let PStepperHorizontal = class PStepperHorizontal {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$5);\n    }\n  };\n  PStepperHorizontal.ɵfac = function PStepperHorizontal_Factory(t) {\n    return new (t || PStepperHorizontal)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PStepperHorizontal.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PStepperHorizontal,\n    selectors: [[\"p-stepper-horizontal\"], [\"\", \"p-stepper-horizontal\", \"\"]],\n    inputs: {\n      size: \"size\",\n      theme: \"theme\"\n    },\n    outputs: {\n      stepChange: \"stepChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PStepperHorizontal_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PStepperHorizontal;\n})();\nPStepperHorizontal = __decorate$k([ProxyCmp({\n  inputs: inputs$f\n})], PStepperHorizontal);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$j = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$e = ['disabled', 'state'];\nlet PStepperHorizontalItem = /*#__PURE__*/(() => {\n  let PStepperHorizontalItem = class PStepperHorizontalItem {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PStepperHorizontalItem.ɵfac = function PStepperHorizontalItem_Factory(t) {\n    return new (t || PStepperHorizontalItem)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PStepperHorizontalItem.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PStepperHorizontalItem,\n    selectors: [[\"p-stepper-horizontal-item\"], [\"\", \"p-stepper-horizontal-item\", \"\"]],\n    inputs: {\n      disabled: \"disabled\",\n      state: \"state\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PStepperHorizontalItem_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PStepperHorizontalItem;\n})();\nPStepperHorizontalItem = __decorate$j([ProxyCmp({\n  inputs: inputs$e\n})], PStepperHorizontalItem);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$i = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$d = ['alignLabel', 'checked', 'disabled', 'hideLabel', 'loading', 'stretch', 'tabbable', 'theme'];\nconst outputs$4 = ['switchChange'];\nlet PSwitch = /*#__PURE__*/(() => {\n  let PSwitch = class PSwitch {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$4);\n    }\n  };\n  PSwitch.ɵfac = function PSwitch_Factory(t) {\n    return new (t || PSwitch)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PSwitch.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PSwitch,\n    selectors: [[\"p-switch\"], [\"\", \"p-switch\", \"\"]],\n    inputs: {\n      alignLabel: \"alignLabel\",\n      checked: \"checked\",\n      disabled: \"disabled\",\n      hideLabel: \"hideLabel\",\n      loading: \"loading\",\n      stretch: \"stretch\",\n      tabbable: \"tabbable\",\n      theme: \"theme\"\n    },\n    outputs: {\n      switchChange: \"switchChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PSwitch_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PSwitch;\n})();\nPSwitch = __decorate$i([ProxyCmp({\n  inputs: inputs$d\n})], PSwitch);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$h = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$c = ['caption'];\nconst outputs$3 = ['sortingChange'];\nlet PTable = /*#__PURE__*/(() => {\n  let PTable = class PTable {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$3);\n    }\n  };\n  PTable.ɵfac = function PTable_Factory(t) {\n    return new (t || PTable)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTable.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTable,\n    selectors: [[\"p-table\"], [\"\", \"p-table\", \"\"]],\n    inputs: {\n      caption: \"caption\"\n    },\n    outputs: {\n      sortingChange: \"sortingChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTable_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTable;\n})();\nPTable = __decorate$h([ProxyCmp({\n  inputs: inputs$c\n})], PTable);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$g = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nlet PTableBody = /*#__PURE__*/(() => {\n  let PTableBody = class PTableBody {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTableBody.ɵfac = function PTableBody_Factory(t) {\n    return new (t || PTableBody)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTableBody.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTableBody,\n    selectors: [[\"p-table-body\"], [\"\", \"p-table-body\", \"\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTableBody_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTableBody;\n})();\nPTableBody = __decorate$g([ProxyCmp({})], PTableBody);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$f = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$b = ['multiline'];\nlet PTableCell = /*#__PURE__*/(() => {\n  let PTableCell = class PTableCell {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTableCell.ɵfac = function PTableCell_Factory(t) {\n    return new (t || PTableCell)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTableCell.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTableCell,\n    selectors: [[\"p-table-cell\"], [\"\", \"p-table-cell\", \"\"]],\n    inputs: {\n      multiline: \"multiline\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTableCell_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTableCell;\n})();\nPTableCell = __decorate$f([ProxyCmp({\n  inputs: inputs$b\n})], PTableCell);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$e = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nlet PTableHead = /*#__PURE__*/(() => {\n  let PTableHead = class PTableHead {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTableHead.ɵfac = function PTableHead_Factory(t) {\n    return new (t || PTableHead)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTableHead.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTableHead,\n    selectors: [[\"p-table-head\"], [\"\", \"p-table-head\", \"\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTableHead_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTableHead;\n})();\nPTableHead = __decorate$e([ProxyCmp({})], PTableHead);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$d = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$a = ['hideLabel', 'multiline', 'sort'];\nlet PTableHeadCell = /*#__PURE__*/(() => {\n  let PTableHeadCell = class PTableHeadCell {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTableHeadCell.ɵfac = function PTableHeadCell_Factory(t) {\n    return new (t || PTableHeadCell)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTableHeadCell.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTableHeadCell,\n    selectors: [[\"p-table-head-cell\"], [\"\", \"p-table-head-cell\", \"\"]],\n    inputs: {\n      hideLabel: \"hideLabel\",\n      multiline: \"multiline\",\n      sort: \"sort\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTableHeadCell_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTableHeadCell;\n})();\nPTableHeadCell = __decorate$d([ProxyCmp({\n  inputs: inputs$a\n})], PTableHeadCell);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$c = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nlet PTableHeadRow = /*#__PURE__*/(() => {\n  let PTableHeadRow = class PTableHeadRow {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTableHeadRow.ɵfac = function PTableHeadRow_Factory(t) {\n    return new (t || PTableHeadRow)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTableHeadRow.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTableHeadRow,\n    selectors: [[\"p-table-head-row\"], [\"\", \"p-table-head-row\", \"\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTableHeadRow_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTableHeadRow;\n})();\nPTableHeadRow = __decorate$c([ProxyCmp({})], PTableHeadRow);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$b = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nlet PTableRow = /*#__PURE__*/(() => {\n  let PTableRow = class PTableRow {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTableRow.ɵfac = function PTableRow_Factory(t) {\n    return new (t || PTableRow)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTableRow.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTableRow,\n    selectors: [[\"p-table-row\"], [\"\", \"p-table-row\", \"\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTableRow_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTableRow;\n})();\nPTableRow = __decorate$b([ProxyCmp({})], PTableRow);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$a = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$9 = ['activeTabIndex', 'gradientColorScheme', 'size', 'theme', 'weight'];\nconst outputs$2 = ['tabChange'];\nlet PTabs = /*#__PURE__*/(() => {\n  let PTabs = class PTabs {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$2);\n    }\n  };\n  PTabs.ɵfac = function PTabs_Factory(t) {\n    return new (t || PTabs)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTabs.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTabs,\n    selectors: [[\"p-tabs\"], [\"\", \"p-tabs\", \"\"]],\n    inputs: {\n      activeTabIndex: \"activeTabIndex\",\n      gradientColorScheme: \"gradientColorScheme\",\n      size: \"size\",\n      theme: \"theme\",\n      weight: \"weight\"\n    },\n    outputs: {\n      tabChange: \"tabChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTabs_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTabs;\n})();\nPTabs = __decorate$a([ProxyCmp({\n  inputs: inputs$9\n})], PTabs);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$9 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$8 = ['activeTabIndex', 'gradientColorScheme', 'size', 'theme', 'weight'];\nconst outputs$1 = ['tabChange'];\nlet PTabsBar = /*#__PURE__*/(() => {\n  let PTabsBar = class PTabsBar {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs$1);\n    }\n  };\n  PTabsBar.ɵfac = function PTabsBar_Factory(t) {\n    return new (t || PTabsBar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTabsBar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTabsBar,\n    selectors: [[\"p-tabs-bar\"], [\"\", \"p-tabs-bar\", \"\"]],\n    inputs: {\n      activeTabIndex: \"activeTabIndex\",\n      gradientColorScheme: \"gradientColorScheme\",\n      size: \"size\",\n      theme: \"theme\",\n      weight: \"weight\"\n    },\n    outputs: {\n      tabChange: \"tabChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTabsBar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTabsBar;\n})();\nPTabsBar = __decorate$9([ProxyCmp({\n  inputs: inputs$8\n})], PTabsBar);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$8 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$7 = ['label'];\nlet PTabsItem = /*#__PURE__*/(() => {\n  let PTabsItem = class PTabsItem {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTabsItem.ɵfac = function PTabsItem_Factory(t) {\n    return new (t || PTabsItem)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTabsItem.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTabsItem,\n    selectors: [[\"p-tabs-item\"], [\"\", \"p-tabs-item\", \"\"]],\n    inputs: {\n      label: \"label\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTabsItem_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTabsItem;\n})();\nPTabsItem = __decorate$8([ProxyCmp({\n  inputs: inputs$7\n})], PTabsItem);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$7 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$6 = ['color', 'icon', 'iconSource', 'theme'];\nlet PTag = /*#__PURE__*/(() => {\n  let PTag = class PTag {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTag.ɵfac = function PTag_Factory(t) {\n    return new (t || PTag)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTag.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTag,\n    selectors: [[\"p-tag\"], [\"\", \"p-tag\", \"\"]],\n    inputs: {\n      color: \"color\",\n      icon: \"icon\",\n      iconSource: \"iconSource\",\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTag_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTag;\n})();\nPTag = __decorate$7([ProxyCmp({\n  inputs: inputs$6\n})], PTag);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$6 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$5 = ['aria', 'color', 'label'];\nlet PTagDismissible = /*#__PURE__*/(() => {\n  let PTagDismissible = class PTagDismissible {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTagDismissible.ɵfac = function PTagDismissible_Factory(t) {\n    return new (t || PTagDismissible)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTagDismissible.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTagDismissible,\n    selectors: [[\"p-tag-dismissible\"], [\"\", \"p-tag-dismissible\", \"\"]],\n    inputs: {\n      aria: \"aria\",\n      color: \"color\",\n      label: \"label\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTagDismissible_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTagDismissible;\n})();\nPTagDismissible = __decorate$6([ProxyCmp({\n  inputs: inputs$5\n})], PTagDismissible);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$5 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$4 = ['align', 'color', 'ellipsis', 'size', 'tag', 'theme', 'weight'];\nlet PText = /*#__PURE__*/(() => {\n  let PText = class PText {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PText.ɵfac = function PText_Factory(t) {\n    return new (t || PText)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PText.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PText,\n    selectors: [[\"p-text\"], [\"\", \"p-text\", \"\"]],\n    inputs: {\n      align: \"align\",\n      color: \"color\",\n      ellipsis: \"ellipsis\",\n      size: \"size\",\n      tag: \"tag\",\n      theme: \"theme\",\n      weight: \"weight\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PText_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PText;\n})();\nPText = __decorate$5([ProxyCmp({\n  inputs: inputs$4\n})], PText);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$4 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$3 = ['actionIcon', 'actionLoading', 'description', 'hideLabel', 'label', 'message', 'showCharacterCount', 'state', 'unit', 'unitPosition'];\nconst outputs = ['action'];\nlet PTextFieldWrapper = /*#__PURE__*/(() => {\n  let PTextFieldWrapper = class PTextFieldWrapper {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, outputs);\n    }\n  };\n  PTextFieldWrapper.ɵfac = function PTextFieldWrapper_Factory(t) {\n    return new (t || PTextFieldWrapper)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTextFieldWrapper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTextFieldWrapper,\n    selectors: [[\"p-text-field-wrapper\"], [\"\", \"p-text-field-wrapper\", \"\"]],\n    inputs: {\n      actionIcon: \"actionIcon\",\n      actionLoading: \"actionLoading\",\n      description: \"description\",\n      hideLabel: \"hideLabel\",\n      label: \"label\",\n      message: \"message\",\n      showCharacterCount: \"showCharacterCount\",\n      state: \"state\",\n      unit: \"unit\",\n      unitPosition: \"unitPosition\"\n    },\n    outputs: {\n      action: \"action\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTextFieldWrapper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTextFieldWrapper;\n})();\nPTextFieldWrapper = __decorate$4([ProxyCmp({\n  inputs: inputs$3\n})], PTextFieldWrapper);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$3 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$2 = ['listType', 'orderType', 'theme'];\nlet PTextList = /*#__PURE__*/(() => {\n  let PTextList = class PTextList {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTextList.ɵfac = function PTextList_Factory(t) {\n    return new (t || PTextList)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTextList.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTextList,\n    selectors: [[\"p-text-list\"], [\"\", \"p-text-list\", \"\"]],\n    inputs: {\n      listType: \"listType\",\n      orderType: \"orderType\",\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTextList_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTextList;\n})();\nPTextList = __decorate$3([ProxyCmp({\n  inputs: inputs$2\n})], PTextList);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$2 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nlet PTextListItem = /*#__PURE__*/(() => {\n  let PTextListItem = class PTextListItem {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTextListItem.ɵfac = function PTextListItem_Factory(t) {\n    return new (t || PTextListItem)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTextListItem.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTextListItem,\n    selectors: [[\"p-text-list-item\"], [\"\", \"p-text-list-item\", \"\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTextListItem_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTextListItem;\n})();\nPTextListItem = __decorate$2([ProxyCmp({})], PTextListItem);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate$1 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs$1 = ['description', 'hideLabel', 'label', 'message', 'showCharacterCount', 'state'];\nlet PTextareaWrapper = /*#__PURE__*/(() => {\n  let PTextareaWrapper = class PTextareaWrapper {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PTextareaWrapper.ɵfac = function PTextareaWrapper_Factory(t) {\n    return new (t || PTextareaWrapper)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PTextareaWrapper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PTextareaWrapper,\n    selectors: [[\"p-textarea-wrapper\"], [\"\", \"p-textarea-wrapper\", \"\"]],\n    inputs: {\n      description: \"description\",\n      hideLabel: \"hideLabel\",\n      label: \"label\",\n      message: \"message\",\n      showCharacterCount: \"showCharacterCount\",\n      state: \"state\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PTextareaWrapper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PTextareaWrapper;\n})();\nPTextareaWrapper = __decorate$1([ProxyCmp({\n  inputs: inputs$1\n})], PTextareaWrapper);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst inputs = ['theme'];\nlet PToast = /*#__PURE__*/(() => {\n  let PToast = class PToast {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  PToast.ɵfac = function PToast_Factory(t) {\n    return new (t || PToast)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  PToast.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PToast,\n    selectors: [[\"p-toast\"], [\"\", \"p-toast\", \"\"]],\n    inputs: {\n      theme: \"theme\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PToast_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  PToast = __decorate([ProxyCmp({\n    inputs\n  })], PToast);\n  return PToast;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DECLARATIONS = [PAccordion, PBanner, PButton, PButtonGroup, PButtonPure, PCarousel, PCheckboxWrapper, PContentWrapper, PDivider, PFieldsetWrapper, PFlex, PFlexItem, PGrid, PGridItem, PHeadline, PIcon, PInlineNotification, PLink, PLinkPure, PLinkSocial, PLinkTile, PMarque, PModal, PPagination, PPopover, PRadioButtonWrapper, PScroller, PSegmentedControl, PSegmentedControlItem, PSelectWrapper, PSpinner, PStepperHorizontal, PStepperHorizontalItem, PSwitch, PTable, PTableBody, PTableCell, PTableHead, PTableHeadCell, PTableHeadRow, PTableRow, PTabs, PTabsBar, PTabsItem, PTag, PTagDismissible, PText, PTextFieldWrapper, PTextList, PTextListItem, PTextareaWrapper, PToast];\nclass DefaultConfig {\n  constructor() {\n    this.prefix = '';\n  }\n}\nlet PorscheDesignSystemModule = /*#__PURE__*/(() => {\n  class PorscheDesignSystemModule {\n    constructor(configParam) {\n      const configs = configParam || [new DefaultConfig()];\n      configs.forEach(({\n        prefix\n      }) => load({\n        prefix\n      }));\n    }\n    static load(config) {\n      return {\n        ngModule: PorscheDesignSystemModule,\n        providers: [{\n          provide: DefaultConfig,\n          multi: true,\n          useValue: config\n        }]\n      };\n    }\n  }\n  PorscheDesignSystemModule.ɵfac = function PorscheDesignSystemModule_Factory(t) {\n    return new (t || PorscheDesignSystemModule)(i0.ɵɵinject(DefaultConfig, 8));\n  };\n  PorscheDesignSystemModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PorscheDesignSystemModule\n  });\n  PorscheDesignSystemModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return PorscheDesignSystemModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToastManager = /*#__PURE__*/(() => {\n  class ToastManager {\n    addMessage(message) {\n      const toast = document.body.querySelector('p-toast,[p-toast]');\n      customElements.whenDefined(toast.tagName.toLowerCase()).then(() => toast.addMessage(message));\n    }\n  }\n  ToastManager.ɵfac = function ToastManager_Factory(t) {\n    return new (t || ToastManager)();\n  };\n  ToastManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ToastManager,\n    factory: ToastManager.ɵfac,\n    providedIn: 'root'\n  });\n  return ToastManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DECLARATIONS, PAccordion, PBanner, PButton, PButtonGroup, PButtonPure, PCarousel, PCheckboxWrapper, PContentWrapper, PDivider, PFieldsetWrapper, PFlex, PFlexItem, PGrid, PGridItem, PHeadline, PIcon, PInlineNotification, PLink, PLinkPure, PLinkSocial, PLinkTile, PMarque, PModal, PPagination, PPopover, PRadioButtonWrapper, PScroller, PSegmentedControl, PSegmentedControlItem, PSelectWrapper, PSpinner, PStepperHorizontal, PStepperHorizontalItem, PSwitch, PTable, PTableBody, PTableCell, PTableHead, PTableHeadCell, PTableHeadRow, PTableRow, PTabs, PTabsBar, PTabsItem, PTag, PTagDismissible, PText, PTextFieldWrapper, PTextList, PTextListItem, PTextareaWrapper, PToast, PorscheDesignSystemModule, ToastManager };\n//# sourceMappingURL=porsche-design-system-components-angular.mjs.map","map":null,"metadata":{},"sourceType":"module"}